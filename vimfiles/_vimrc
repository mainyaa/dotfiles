

"--------------------------------------------------
" Plugin
" :PluginInstall
"--------------------------------------------------
set nocompatible               " be iMproved
filetype off                   " required!

set rtp+=~/_vim/vundle.git/
call vundle#begin('~/_vim/bundle')
let g:vundle_default_git_proto = 'git'

Plugin 'VundleVim/Vundle.vim'
" ruby
"Plugin 'tpope/vim-rails'
" python
"Plugin 'pyflakes.vim'
Plugin 'vim-scripts/Pydiction'
Plugin 'davidhalter/jedi-vim'
"Plugin 'django.vim'
"Plugin 'django_templates.vim'
"Plugin 'Django-helper-utils'
" java
Plugin 'java.vim'
Plugin 'javacomplete'
"Plugin 'git://github.com/koron/java-helper-vim'
"Plugin 'jcommenter.vim'
Plugin 'git://github.com/moznion/jcommenter.vim'
"Plugin 'pwicks86/eclim-for-vundle'
" scala
Plugin 'Scala-Java-Edit'
Plugin 'scala.vim'
" cpp
Plugin 'cpp.vim'
Plugin 'vim-cpp-auto-include'
Plugin 'Cppcheck-compiler'
Plugin 'justmao945/vim-clang'
Plugin 'octol/vim-cpp-enhanced-highlight'
" c#
Plugin 'vim-scripts/aspnetcs'
" js
Plugin 'pangloss/vim-javascript'
Plugin 'walm/jshint.vim'
Plugin 'xer0x/jsbeautify'
"Plugin 'tyok/js-mask'
Plugin 'leshill/vim-json'
Plugin 'jelera/vim-javascript-syntax'
Plugin 'othree/javascript-libraries-syntax.vim'
"Plugin 'nkzawa/js-inspector.vim'
Plugin 'maksimr/vim-jsbeautify'
Plugin 'einars/js-beautify'
" typescript
Plugin 'leafgarland/typescript-vim'
Plugin 'mhartington/vim-typings'
Plugin 'Quramy/tsuquyomi'
" coffeescript
Plugin 'kchmck/vim-coffee-script'
" ActionScript
Plugin 'actionscript.vim'
" haskell
Plugin 'haskell.vim'
Plugin 'eagletmt/ghcmod-vim'
" groovy
Plugin 'groovy.vim'
" Plugin 'groovyindent'
Plugin 'tfnico/vim-gradle'
" go
"Plugin 'Go-Syntax'
"Plugin 'go.vim'
"Plugin 'jnwhiteh/vim-golang'
"Plugin 'nsf/gocode', {'rtp': 'vim/'}
Plugin 'fatih/vim-go'
" Docker
Plugin 'ekalinin/Dockerfile.vim'
" Lisp
Plugin 'amdt/vim-niji'
" Dart
Plugin 'dart-lang/dart-vim-plugin'
Plugin 'thosakwe/vim-flutter'
" Elm
Plugin 'ElmCast/elm-vim'
Plugin 'dense-analysis/ale'
" HTML/CSS
Plugin 'vim-scripts/HTML-AutoCloseTag'
Plugin 'ZenCoding.vim'
Plugin 'css3-syntax-plus'
" syntax
" applescript, c, coffee, cpp, css, cucumber, cuda, docbk, erlang, eruby, fortran, gentoo_metadata, go, haml, haskell, html, javascript, json, less, lua, matlab, perl, php, puppet, python, rst, ruby, sass/scss, sh, tcl, tex, vala, xhtml, xml, xslt, yaml, zpt
Plugin 'Syntastic'
Plugin 'roktas/syntastic-more'
"Plugin 'actionscript.vim'
" TOML
Plugin 'cespare/vim-toml'
" server
Plugin 't9md/vim-chef'
Plugin 'httplog'
Plugin 'git://fedorapeople.org/home/fedora/wwoods/public_git/vim-scripts.git'
" shell
Plugin 'Shougo/vimshell.vim'
Plugin 'sh.vim'
Plugin 'Matt-Deacalion/vim-systemd-syntax'
" API Blueprint
Plugin 'kylef/apiblueprint.vim'
" util
Plugin 'recover.vim'
Plugin 't9md/vim-choosewin'
Plugin 'kana/vim-niceblock'
" =の位置を揃える
Plugin 'Align'
Plugin 'AutoAlign'
Plugin 'junegunn/vim-easy-align'
Plugin 'write.vim'
Plugin 'YankRing.vim'
Plugin 'm4i/YankRingSync'
Plugin 'kana/vim-fakeclip'
Plugin 'airblade/vim-rooter'
"Plugin 'rodjek/vim-puppet'
Plugin 'scrooloose/nerdtree'
Plugin 'Shougo/vimfiler'
" snnipet
Plugin 'Shougo/neocomplete'
Plugin 'Shougo/neosnippet'
Plugin 'Shougo/neosnippet-snippets'
Plugin 'honza/vim-snippets'
Plugin 'rcmdnk/vim-octopress-snippets'
"Plugin 'sjbach/lusty'
"Plugin 'gmarik/snipmate.vim'   " errorが起こる
Plugin 'nathanaelkane/vim-indent-guides'
Plugin 'godlygeek/tabular'
Plugin 'tabpagecd'
"Plugin 'Raimondi/delimitMate'
Plugin 'scrooloose/nerdcommenter'
Plugin 'tpope/vim-surround'
"Plugin 'wincent/Command-T'
Plugin 'pdurbin/vim-tsv'
"Plugin 'Lokaltog/vim-powerline'
Plugin 'itchyny/lightline.vim'
Plugin 'itchyny/landscape.vim'
Plugin 'sickill/vim-pasta'
"Plugin 'ervandew/supertab'
Plugin 'tpope/vim-endwise'
"Plugin 'scrooloose/syntastic'
"Plugin 'w0rp/ale'
Plugin 'AutoComplPop'
Plugin 'thinca/vim-ft-help_fold'
Plugin 'savevers.vim'
" command
Plugin 'quickrun.vim'
"Plugin 'Shougo/vimproc.vim' " Aynchronous execution plugin for Vim
"Plugin 'git://git.wincent.com/command-t.git'
" git
Plugin 'tpope/vim-fugitive'
Plugin 'hotwatermorning/auto-git-diff'
" VimDiff(histogram argorihtm)
Plugin 'lambdalisue/vim-unified-diff'
" paste mode
Plugin 'ConradIrwin/vim-bracketed-paste'
" move
Plugin 'Lokaltog/vim-easymotion'
Plugin 'camelcasemotion'
" coverrage
Plugin 'gcov.vim'
Plugin 'GCov-plugin'
" color
Plugin 'AnsiEsc.vim'
Plugin 'flazz/vim-colorschemes'
Plugin 'Low-Contrast-Color-Schemes'
"Plugin 'CSApprox'
Plugin 'tomasr/molokai'
" search
Plugin 'smartchr'
Plugin 'eregex.vim'
Plugin 'The-NERD-tree'
Plugin 'mileszs/ack.vim'
Plugin 'rking/ag.vim'
"Plugin 'ag.vim'
Plugin 'nerdtree-ack'
" IME
"Plugin 'fuenor/im_control.vim'
" TextMate's like
"Plugin 'vim-scripts/snippetsEmu'
" tag jump
Plugin 'majutsushi/tagbar'
Plugin 'matchit.zip'
Plugin 'kien/ctrlp.vim'
Plugin 'ctags.vim'
Plugin 'soramugi/auto-ctags.vim'
Plugin 'gtags.vim'
Plugin 'wesleyche/SrcExpl'
Plugin 'terryma/vim-multiple-cursors'
" unite.vim
Plugin 'unite.vim'
"Plugin 'unite-yarm'
Plugin 'unite-gem'
Plugin 'unite-scriptenames'
Plugin 'unite-locate'
Plugin 'unite-font'
Plugin 'unite-colorscheme'
"Plugin 'git://github.com/kmnk/vim-unite-git'
" keymap
Plugin 'kana/vim-submode'
" MacApp
Plugin 'rizzatti/dash.vim'

" develop plugins
Plugin 'vim-ecmascript-syntax', {'pinned': 1}

call vundle#end()            " required
filetype plugin indent on    " required

"--------------------------------------------------
" Default settings
"--------------------------------------------------
set encoding=utf-8
set fileencodings=utf-8,iso-2022-jp,sjis
set smartcase
set incsearch
set ignorecase
set tabstop=4
set expandtab
"set cindent
set backspace=indent,eol,start
set showmatch
set matchtime=3
"set wildmenu
"set wildmode=longest:full,full
set number
set list
set cursorline
set visualbell t_vb=
set helplang=ja,en
"colorscheme Dark
"colorscheme molokai
colorscheme Dark
let &guifont='SourceCodePro-Light'
filetype plugin on
filetype indent on
let g:vim_indent_cont = &sw
"let g:vim_indent_cont = &sw * 2
set tabstop=4 expandtab shiftwidth=4 softtabstop=4

" CWD > .tags > sub-direcotry > parent > parent-parent > $HOME
set tags+=tags,./tags,.tags,.git/tags,src/tags,**/tags,../../tags,../tags,~/_vim/tags/python/python.tags,~/.vim/stdtags,

"set statusline=%F%m%r%h%w\ [T:%Y]\ [P:%l,%v][%p%%]\ [L:%L]\ [T:%Y]
set statusline=\ %F%m%r%h%w\ [%v,%l/%L][%p%%][%Y]%m%{'['.(&fenc!=''?&fenc:&enc).']'}%=%l,%c%V%8P
set laststatus=1

"--------------------------------------------------
" filetype
"--------------------------------------------------
au BufRead *access_log* setf httplog
au BufNewFile,BufRead *.tmpl  setf tmpl
au BufNewFile,BufRead *.as  setf actionscript
au BufNewFile,BufReadPost *.apib setl shiftwidth=4 expandtab
au BufNewFile,BufReadPost *.rb setl shiftwidth=2 expandtab
autocmd BufRead,BufNewFile *.es setfiletype javascript
autocmd BufRead,BufNewFile *.ts setfiletype typescript
autocmd BufRead,BufNewFile *.es6 setfiletype javascript
autocmd BufRead,BufNewFile *.as setfiletype actionscript
autocmd BufRead,BufNewFile *.go setfiletype go

"--------------------------------------------------
" CoffeeScirpt
"--------------------------------------------------
" autocmd BufWritePost *.coffee silent CoffeeMake! -cb | cwindow
au BufNewFile,BufReadPost *.coffee setl shiftwidth=2 expandtab
" Plugin Boolean settings for Programming Languages
let coffee_compile_vert=1 " When compiling CoffeeScript, throw output into vertical split
let coffee_make_options='--bare'
" Auto-compile coffee files on save.
"au BufWritePost *.coffee silent CoffeeMake!
" Auto-compile less files on save.

"--------------------------------------------------
" Java
"--------------------------------------------------
set sm
set ai
set complete=.,w,b,u,t,i
syntax on
let g:java_highlight_all       = 1
let g:java_highlight_debug     = 1
let g:java_allow_cpp_keywords  = 1
let g:java_space_errors        = 0
let g:java_highlight_functions = 1
let java_highlight_all         = 1
let java_highlight_functions   = "style"
let java_allow_cpp_keywords    = 1
"autocmd FileType java setl noexpandtab
autocmd FileType java setl tabstop=4 noexpandtab shiftwidth=4 softtabstop=4
autocmd FileType xml setl tabstop=4 noexpandtab shiftwidth=4 softtabstop=4
autocmd FileType css setl tabstop=2 expandtab shiftwidth=2 softtabstop=2
autocmd FileType scss setl tabstop=2 expandtab shiftwidth=2 softtabstop=2
autocmd FileType java :setlocal omnifunc=javacomplete#Complete
autocmd FileType java :setlocal completefunc=javacomplete#CompleteParamsInfo
autocmd FileType java source $HOME/_vim/bundle/jcommenter.vim/plugin/jcommenter.vim
autocmd FileType java map <C-c> :call JCommentWriter()<CR>

"--------------------------------------------------
" Python
"--------------------------------------------------
let g:pydiction_location    = '~/_vim/after/ftplugin/pydiction/complete-dict'
let g:pydiction_menu_height = 20
let python_highlight_all    = 1
autocmd FileType python setl autoindent
autocmd FileType python setl smartindent cinwords=if,elif,else,for,while,try,except,finally,def,class
autocmd FileType python setl tabstop=8 expandtab shiftwidth=4 softtabstop=4
" Execute python script C-P
function! s:ExecPy()
    exe "!" . &ft . " %"
endfunction
command! Exec call <SID>ExecPy()
autocmd FileType python map <silent> <C-P> :call <SID>ExecPy()<CR>
" Turn on completion:
setlocal omnifunc=pythoncomplete#Complete

" Python Syntax Check
function! PythonGrep(tool)
    set lazyredraw
    " Close any existing cwindows.
    cclose
    let l:grepformat_save = &grepformat
    let l:grepprogram_save = &grepprg
    set grepformat&vim
    set grepformat&vim
    let &grepformat = '%f:%l:%m'
    if a:tool == "pylint"
        let &grepprg = 'pylint --output-format=parseable --reports=n --rcfile=$HOME/.pylint --indent-string="        "'
    elseif a:tool == "pychecker"
        let &grepprg = 'pychecker --quiet -q'
    elseif a:tool == "pyflakes"
        let &grepprg = 'pyflakes'
    else
        echohl WarningMsg
        echo "PythonGrep Error: Unknown Tool"
        echohl none
    endif
    if &readonly == 0 | update | endif
    silent! grep! %
    let &grepformat = l:grepformat_save
    let &grepprg = l:grepprogram_save
    let l:mod_total = -20
    let l:win_count = 1
    " Determine correct window height
    windo let l:win_count = l:win_count + 1
    if l:win_count <= 2 | let l:win_count = 4 | endif
    windo let l:mod_total = l:mod_total + winheight(0)/l:win_count |
    "execute 'resize +'.l:mod_total
    " Open cwindow
    execute 'belowright cw '.l:mod_total
    nnoremap   c :cclose
    set nolazyredraw
    redraw!
endfunction

command! Pyflakes call PythonGrep('pyflakes')
command! PyFlakes call PythonGrep('pyflakes')
command! Pychecker call PythonGrep('pychecker')
command! PyChecker call PythonGrep('pychecker')
command! Pylint call PythonGrep('pylint')
command! PyLint call PythonGrep('pylint')

" Indent Python in the Google way.

setlocal indentexpr=GetGooglePythonIndent(v:lnum)

let s:maxoff = 50 " maximum number of lines to look backwards.

function! GetGooglePythonIndent(lnum)

    " Indent inside parens.
    " Align with the open paren unless it is at the end of the line.
    " E.g.
    "   open_paren_not_at_EOL(100,
    "                         (200,
    "                          300),
    "                         400)
    "   open_paren_at_EOL(
    "       100, 200, 300, 400)
    call cursor(a:lnum, 1)
    let [par_line, par_col] = searchpairpos('(\|{\|\[', '', ')\|}\|\]', 'bW',
                    \ "line('.') < " . (a:lnum - s:maxoff) . " ? dummy :"
                    \ . " synIDattr(synID(line('.'), col('.'), 1), 'name')"
                    \ . " =~ '\\(Comment\\|String\\)$'")
    if par_line > 0
        call cursor(par_line, 1)
        if par_col != col("$") - 1
            return par_col
        endif
    endif

    " Delegate the rest to the original function.
    return GetPythonIndent(a:lnum)

endfunction

let pyindent_nested_paren="&sw*2"
let pyindent_open_paren="&sw*2"


"--------------------------------------------------
" Perl
"--------------------------------------------------
" perlhelp.vim
let perl_include_pod=1

" .plを開くと毎回@INCを調べるのを抑制
let g:perlpath="/usr/bin/perl"

" insert debug code
nnoremap <C-c> :call <SID>insert_debug_code()<CR>
function! s:insert_debug_code()
    "    call setline(line('.'), "use Data::Dumper;warn(Dumper(  ));" . getline('.'))
    "    call cursor(line('.'),30)
    call setline(line('.'), "console.log('!')" . getline('.'))
    return ""
endfunction

"--------------------------------------------------
" Go
"--------------------------------------------------
" gocode
set rtp+=$GOROOT/misc/vim
if $GOROOT != ''
    set rtp+=$GOROOT/misc/vim
endif
"golint
exe "set rtp+=" . globpath($GOPATH, "src/github.com/golang/lint/misc/vim")
"vim-go
"let g:go_highlight_functions = 1
let g:go_highlight_methods = 1
let g:go_highlight_fields = 1
let g:go_highlight_types = 1
let g:go_highlight_operators = 1
let g:go_highlight_build_constraints = 1
let g:go_fmt_command = "goimports"

""Vundleの設定
"set rtp+=~/vimfiles/bundle/vundle/
"call vundle#rc('~/vimfiles/bundle')

"" Go
filetype plugin indent on
syntax on

" auto format
auto BufWritePre *.go Fmt

"--------------------------------------------------
" quickrun
"--------------------------------------------------
let g:quickrun_config = {}
let g:quickrun_config['coffee'] = {'command' : 'coffee', 'exec' : ['%c -cbp %s']}
let g:quickrun_config['py'] = {'command' : 'pyflakes', 'exec' : ['%c %s']}

"-------------------------------------------------------------------------------
" 補完・履歴 Complete
"-------------------------------------------------------------------------------
set wildmenu               " コマンド補完を強化
set wildchar=<tab>         " コマンド補完を開始するキー
set wildmode=list:full     " リスト表示，最長マッチ
set history=1000           " コマンド・検索パターンの履歴数
set complete+=k            " 補完に辞書ファイル追加

" Ex-modeでの<C-p><C-n>をzshのヒストリ補完っぽくする
cnoremap <C-p> <Up>
cnoremap <Up>  <C-p>
cnoremap <C-n> <Down>
cnoremap <Down>  <C-n>

" 補完にneocomplcacheを使う
"source ~/src/dotfiles/.vimrc.completion.neocomplcache

"------------------------------------
" neocmplcache
"------------------------------------
" Disable AutoComplPop.
let g:acp_enableAtStartup = 1
" Use neocomplcache.
let g:neocomplete#enable_at_startup = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplete#min_syntax_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

" Enable heavy features.
" Use camel case completion.
"let g:neocomplete#enable_camel_case_completion = 1
" Use underbar completion.
"let g:neocomplete#enable_underbar_completion = 1

" Define dictionary.
let g:neocomplete#dictionary_filetype_lists = {
                \ 'default' : '',
                \ 'vimshell' : $HOME.'/_vimshell_hist',
                \ 'scheme' : $HOME.'/.gosh_completions'
                \ }

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplcache#undo_completion()
inoremap <expr><C-l>     neocomplcache#complete_common_string()

" Or set this.
"let g:neocomplete#enable_cursor_hold_i = 1
" Or set this.
"let g:neocomplete#enable_insert_char_pre = 1

" AutoComplPop like behavior.
"let g:neocomplete#enable_auto_select = 1

" Shell like behavior(not recommended).
set completeopt+=longest
let g:neocomplete#enable_auto_select = 1
let g:neocomplete#disable_auto_complete = 1

inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
"autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
if !exists('g:neocomplete#omni_patterns')
    let g:neocomplete#omni_patterns = {}
endif
let g:neocomplete#omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
let g:neocomplete#omni_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
let g:neocomplete#omni_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
"let g:neocomplete#sources#omni#input_patterns.typescript = '\h\w*\|[^. \t]\.\w*'

" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
let g:neocomplete#omni_patterns.perl = '\h\w*->\h\w*\|\h\w*::'

" 自動補完してEnterを入力すると、インデントがおかしくなる問題の修正
inoremap pumvisible() ? neocomplcache#close_popup().“\X\” : “\X\”

"--------------------------------------------------
" autocmd
"--------------------------------------------------
" These three are successively more informative and aggressive in their
" warnings with pyflakes as the least noisy. Only uncomment one.
"autocmd BufWrite *.{py} :Pyflakes
"autocmd BufWrite *.{py} :Pychecker
"autocmd BufWrite *.{py} :Pylint




"--------------------------------------------------
" バックアップと比較
"--------------------------------------------------
set backup
set backupdir=$HOME/.txtb
set undodir=$HOME/.txtb
set patchmode=.clean
let savevers_types = "*"
let savevers_dirs = &backupdir
let versdiff_no_resize=1

" lambdalisue/vim-unified-diff
"set diffexpr=unified_diff#diffexpr()
"set patchexpr=unified_diff#diffexpr()
"set diffopt='icase,iwhite'

" vimdiffの色設定
highlight DiffAdd    cterm=bold ctermfg=252 ctermbg=22
highlight DiffDelete cterm=bold ctermfg=252 ctermbg=52
highlight DiffChange cterm=bold ctermfg=252 ctermbg=0
highlight DiffText   cterm=bold ctermfg=252 ctermbg=17

nmap <silent> <F5> :VersDiff -<CR>
nmap <silent> <F6> :VersDiff +<CR>
nmap <silent> <F8> :VersDiff -c<CR>




"--------------------------------------------------
" auto save
"--------------------------------------------------
" set autowrite
" " set autowriteall
" autocmd CursorHold *  wall
" autocmd CursorHoldI *  wall

"--------------------------------------------------
" 行末の空白を保存時に自動削除
"--------------------------------------------------
" autocmd BufWritePre * :%s/\s\+$//e

"--------------------------------------------------
" .vimrc保存時に自動リロード
"--------------------------------------------------
" .vimrcをリロード可能な形式にする
" http://whileimautomaton.net/2008/08/vimworkshop3-kana-presentation
let reloadvim = 0
autocmd FileType vim let reloadvim = 1
if reloadvim == 1
    autocmd BufWritePost * :source $MYVIMRC
endif

"--------------------------------------------------
" インサートモードを抜けたらIMEの日本語入力を自動的にOFFにする
"--------------------------------------------------
"inoremap <silent> <ESC> <ESC>:set iminsert=0<CR>

"--------------------------------------------------
" 文字コードの自動認識
"--------------------------------------------------
if &encoding !=# 'utf-8'
    set encoding=japan
    set fileencoding=japan
endif
if has('iconv')
    let s:enc_euc = 'euc-jp'
    let s:enc_jis = 'iso-2022-jp'
    " iconvがeucJP-msに対応しているかをチェック
    if iconv("\x87\x64\x87\x6a", 'cp932', 'eucjp-ms') ==# "\xad\xc5\xad\xcb"
        let s:enc_euc = 'eucjp-ms'
        let s:enc_jis = 'iso-2022-jp-3'
        " iconvがJISX0213に対応しているかをチェック
    elseif iconv("\x87\x64\x87\x6a", 'cp932', 'euc-jisx0213') ==# "\xad\xc5\xad\xcb"
        let s:enc_euc = 'euc-jisx0213'
        let s:enc_jis = 'iso-2022-jp-3'
    endif
    " fileencodingsを構築
    if &encoding ==# 'utf-8'
        let s:fileencodings_default = &fileencodings
        let &fileencodings = s:enc_jis .','. s:enc_euc .',cp932'
        let &fileencodings = &fileencodings .','. s:fileencodings_default
        unlet s:fileencodings_default
    else
        let &fileencodings = &fileencodings .','. s:enc_jis
        set fileencodings+=utf-8,ucs-2le,ucs-2
        if &encoding =~# '^\(euc-jp\|euc-jisx0213\|eucjp-ms\)$'
            set fileencodings+=cp932
            set fileencodings-=euc-jp
            set fileencodings-=euc-jisx0213
            set fileencodings-=eucjp-ms
            let &encoding = s:enc_euc
            let &fileencoding = s:enc_euc
        else
            let &fileencodings = &fileencodings .','. s:enc_euc
        endif
    endif
    " 定数を処分
    unlet s:enc_euc
    unlet s:enc_jis
endif
" 日本語を含まない場合は fileencoding に encoding を使うようにする
if has('autocmd')
    function! AU_ReCheck_FENC()
        if &fileencoding =~# 'iso-2022-jp' && search("[^\x01-\x7e]", 'n') == 0
            let &fileencoding=&encoding
        endif
    endfunction
    autocmd BufReadPost * call AU_ReCheck_FENC()
endif
" 改行コードの自動認識
set fileformats=unix,dos,mac
" □とか○の文字があってもカーソル位置がずれないようにする
if exists('&ambiwidth')
    set ambiwidth=double
endif

"--------------------------------------------------
" Emacs風に
"--------------------------------------------------

"カーソル一文字単位移動
inoremap <C-s> <Left>
inoremap <silent> <C-s> <Left>
inoremap <C-d> <Right>
inoremap <silent> <C-d> <Right>

""単語単位移動
inoremap <C-f> <C-r>=MyMoveWord_i('w')<CR>
inoremap <silent> <C-f> <C-r>=MyMoveWord_i('w')<CR>
inoremap <C-b> <C-r>=MyMoveWord_i('b')<CR>
inoremap <silent> <C-b> <C-r>=MyMoveWord_i('b')<CR>

"非補完時は行移動をj,kと同じ動作にして補完中は候補選択
inoremap <expr> <C-p>  pumvisible() ? "\<C-p>" :
inoremap <silent> <expr> <C-p>  pumvisible() ? "\<C-p>" :
""<C-r>=MyExecExCommand('normal k')<CR>"
inoremap <expr> <C-n>  pumvisible() ? "\<C-n>" : "<C-r>=MyExecExCommand('normal j')<CR>"
inoremap <silent> <expr> <C-n>  pumvisible() ? "\<C-n>" : "<C-r>=MyExecExCommand('normal j')<CR>"
inoremap <expr> <Up>   pumvisible() ? "\<C-p>" : "<C-r>=MyExecExCommand('normal k')<CR>"
inoremap <silent> <expr> <Up>   pumvisible() ? "\<C-p>" : "<C-r>=MyExecExCommand('normal k')<CR>"
inoremap <expr> <Down> pumvisible() ? "\<C-n>" : "<C-r>=MyExecExCommand('normal j')<CR>"
inoremap <silent> <expr> <Down> pumvisible() ? "\<C-n>" : "<C-r>=MyExecExCommand('normal j')<CR>"

"行頭へ
inoremap <silent> <C-a> <C-r>=MyJumptoBol('')<CR>
inoremap <C-a> <C-r>=MyJumptoBol('')<CR>
""行末へ
inoremap <silent> <C-e> <C-r>=MyJumptoEol('')<CR>
inoremap <C-e> <C-r>=MyJumptoEol('')<CR>


"カーソル前の文字削除
inoremap <silent> <BS>  <C-g>u<BS>
inoremap <silent> <C-h> <C-g>u<C-h>
"カーソル後の文字削除
inoremap <silent> <Del> <C-g>u<Del>
inoremap <silent> <C-g> <C-g>u<Del>

"カーソル位置から前の単語を削除
inoremap <silent> <C-w> <C-g>u<C-r>=MyExecExCommand('normal! db')<CR>
"カーソル位置から後の単語を削除
inoremap <silent> <C-t> <C-g>u<C-r>=MyDeleteWord()<CR>

"最後に挿入した文字列を挿入
inoremap <silent> <C-z> <C-g>u<C-a>

"現在行をインデント
inoremap <silent> <Tab>   <C-g>u<C-t>
inoremap <silent> <S-Tab> <C-g>u<C-d>

"undo
inoremap <silent> <C-u> <C-g>u<C-r>=MyExecExCommand('undo', 'onemore')<CR>

"２ストロークキー使用
if 1
    "カーソル以降削除
    inoremap <silent> <C-k><C-k> <C-g>u<C-r>=MyExecExCommand('normal! D', 'onemore')<CR>
    "redo
    inoremap <silent> <C-k><C-r> <C-r>=MyExecExCommand('redo', 'onemore')<CR>
    "行連結
    inoremap <silent> <C-k><C-j> <C-g>u<C-r>=MyExecExCommand('normal! J')<CR>
    "新行挿入
    inoremap <silent> <C-k><C-n> <C-g>u<C-r>=MyExecExCommand("call cursor(line('.'), col('$'))")<CR><CR>
endif

"メタ(alt)キー使用
if 0
    "カーソル以降削除
    inoremap <silent> <C-k> <C-g>u<C-r>=MyExecExCommand('normal! D', 'onemore')<CR>
    "リドゥ
    inoremap <silent> <M-r> <C-r>=MyExecExCommand('redo', 'onemore')<CR>
    "行連結
    inoremap <silent> <M-j> <C-g>u<C-r>=MyExecExCommand('normal! J')<CR>
    "新行挿入
    inoremap <silent> <M-n> <C-g>u<C-r>=MyExecExCommand("call cursor(line('.'), col('$'))")<CR><CR>
endif

" insert modeでも画面スクロールしたい
" キーリピートを短くしないと効果ない
imap jjjjj <esc>
imap kkkkk <esc>
imap hhhhh <esc>
imap lllll <esc>

"sepが空でなければ、sepをセパレータとしてジャンプ。
""見つからなければ見かけの行頭へ。
"カーソル位置が見かけの行頭の場合は真の行頭へ。
function! MyJumptoBol(sep)
    if col('.') == 1
        call cursor(line('.')-1, col('$'))
        call cursor(line('.'), col('$'))
        return ''
    endif
    if matchend(strpart(getline('.'), 0, col('.')), '[[:blank:]]\+') >= col('.')-1
        silent exec 'normal! 0'
        return ''
    endif
    if a:sep != ''
        call search('[^'.a:sep.']\+', 'bW', line("."))
        if col('.') == 1
            silent exec 'normal! ^'
        endif
        return ''
    endif
    return ''
endfunction

"sepが空でなければ、sepをセパレータとしてジャンプ。
""見つからなければ行末へ。
function! MyJumptoEol(sep)
    if col('.') == col('$')
        silent exec 'normal! w'
        return ''
    endif

    if a:sep != ''
        let prevcol = col('.')
        call search('['.a:sep.']\+[^'.a:sep.']', 'eW', line("."))
        if col('.') != prevcol
            return ''
        endif
    endif
    call cursor(line('.'), col('$'))
    return ''
endfunction

"行末でも停止する単語単位移動コマンド
function! MyMoveWord_i(cmd)
    let isEol = 0
    if col('$') == col('.')
        let isEol = 1
    endif
    let prevline = line('.')
    silent exec 'normal! '.a:cmd
    if line('.') == prevline
        return ''
    endif
    if a:cmd == 'w'
        if isEol == 0
            call cursor(prevline, 0)
            call cursor(line('.'), col('$'))
        endif
        if line('.') - prevline > 1
            call cursor(prevline+1, 0)
            call cursor(line('.'), col('$'))
        endif
    elseif a:cmd == 'b'
        call cursor(line('.'), col('$'))
        if prevline - line('.') > 1
            call cursor(prevline-1, 0)
            call cursor(line('.'), col('$'))
        endif
    endif
    return ''
endfunction

"カーソル以降の単語削除
function! MyDeleteWord()
    if col('.') == col('$')
        return ''
    endif
    let save_cursor = getpos('.')
    silent exec 'normal! wge'
    if save_cursor[1] != line('.') || (save_cursor[2] > col('.'))
        call setpos('.', save_cursor)
        return MyExecExCommand('normal! dw', 'onemore')
    endif
    silent exec 'normal! v'
    call setpos('.', save_cursor)
    return MyExecExCommand('normal! d')
endfunction

"IMEの状態とカーソル位置保存のため<C-r>を使用してコマンドを実行。
function! MyExecExCommand(cmd, ...)
    let saved_ve = &virtualedit
    let index = 1
    while index <= a:0
        if a:{index} == 'onemore'
            silent setlocal virtualedit+=onemore
        endif
        let index = index + 1
    endwhile

    silent exec a:cmd
    if a:0 > 0
        silent exec 'setlocal virtualedit='.saved_ve
    endif
    return ''
endfunction
"FIXME:<C-r>(リドゥ)はコマンドラインからexecで実行すると色々面倒なので回避用
nnoremap g\\z <C-r>

"--------------------------------------------------
" unite.vim
"--------------------------------------------------
" 入力モードで開始する
" let g:unite_enable_start_insert=1
" バッファ一覧
nnoremap <silent> ,ub :<C-u>Unite buffer<CR>
" ファイル一覧
nnoremap <silent> ,uf :<C-u>UniteWithBufferDir -buffer-name=files file<CR>
" レジスタ一覧
nnoremap <silent> ,ur :<C-u>Unite -buffer-name=register register<CR>
" 最近使用したファイル一覧
nnoremap <silent> ,um :<C-u>Unite file_mru<CR>
" 常用セット
nnoremap <silent> ,uu :<C-u>Unite buffer file_mru<CR>
" 全部乗せ
nnoremap <silent> ,ua :<C-u>UniteWithBufferDir -buffer-name=files buffer file_mru bookmark file<CR>

" ウィンドウを分割して開く
au FileType unite nnoremap <silent> <buffer> <expr> <C-j> unite#do_action('split')
au FileType unite inoremap <silent> <buffer> <expr> <C-j> unite#do_action('split')
" ウィンドウを縦に分割して開く
au FileType unite nnoremap <silent> <buffer> <expr> <C-l> unite#do_action('vsplit')
au FileType unite inoremap <silent> <buffer> <expr> <C-l> unite#do_action('vsplit')
" ESCキーを2回押すと終了する
au FileType unite nnoremap <silent> <buffer> <ESC><ESC> q
au FileType unite inoremap <silent> <buffer> <ESC><ESC> <ESC>q

"--------------------------------------------------
" plugin設定
"--------------------------------------------------
" AutoComplPop
"let g:AutoComplPop_IgnoreCaseOption = 1
autocmd FileType javascript let g:AutoComplPop_CompleteOption = '.,w,b,u,t,i,k~/_vim/dict/javascript.dict'
autocmd FileType perl let g:AutoComplPop_CompleteOption = '.,w,b,u,t,k~/_vim/dict/perl_func.dict'

" write.vim
let g:loaded_write = 1
let g:write_auto=['markdown', 'help', 'text!']

"<c-t>で補完
" {{{ Autocompletion using the TAB key
" This function determines, wether we are on the start of the line text (then tab indents) or
" if we want to try autocompletion
function! InsertTabWrapper()
    let col = col('.') - 1
    if !col || getline('.')[col - 1] !~ '\k'
        return "\<TAB>"
    else
        if pumvisible()
            return "\<C-N>"
        else
            return "\<C-N>\<C-P>"
        end
    endif
endfunction

" Remap the tab key to select action with InsertTabWrapper
inoremap <c-t> <c-r>=InsertTabWrapper()<CR>
" }}} Autocompletion using the TAB key

" a command to restore to original text and select the first match

"inoremap <expr> <CR> pumvisible() ? \<C-Y>\<CR>" : "\<CR>"

" %を強化
"source ~/_vim/plugin/matchit.vim


" ack
map <C-W>a :let a=expand("<cword>")<CR>:tabnew<CR>:Ack <C-R>=expand(a)<CR> lib<CR>
map <C-W>A :let a=expand("<cword>")<CR>:tabnew<CR>:Ack <C-R>=expand(a)<CR> ./

" vsp(vnew)-width
nnoremap <C-w><C-h> <C-w>h:call <SID>good_width()<CR>
nnoremap <C-w><C-l> <C-w>l:call <SID>good_width()<CR>
nnoremap <C-w>h <C-w>h:call <SID>good_width()<CR>
nnoremap <C-w>l <C-w>l:call <SID>good_width()<CR>
nnoremap <C-w>H <C-w>H:call <SID>good_width()<CR>
nnoremap <C-w>L <C-w>L:call <SID>good_width()<CR>
nnoremap <C-h> <C-w>h:call <SID>good_width()<CR>
nnoremap <C-l> <C-w>l:call <SID>good_width()<CR>
function! s:good_width()
    if winwidth(0) < 84
        vertical resize 84
    endif
endfunction

" tags
"tags-and-searchesを使い易くする
nnoremap t  <Nop> " 「飛ぶ」
nnoremap tt  g<C-]> "「進む」
nnoremap tb  <C-b> "「戻る」
nnoremap tj  :<C-u>tag<CR> "「戻る」
nnoremap tk  :<C-u>pop<CR> "履歴一覧
nnoremap tl  :<C-u>tags<CR>
nnoremap tv :vsp<CR> :exe("tjump ".expand('<cword>'))<CR>
nnoremap th :split<CR> :exe("tjump ".expand('<cword>'))<CR>

let g:tagbar_type_coffee = {
                \ 'ctagstype' : 'coffee',
                \ 'kinds'     : [
                \ 'c:classes',
                \ 'm:methods',
                \ 'f:functions',
                \ 'v:variables',
                \ 'f:fields',
                \ ]
                \ }

" Posix regular expressions for matching interesting items. Since this will
" be passed as an environment variable, no whitespace can exist in the options
" so [:space:] is used instead of normal whitespaces.
" Adapted from: https://gist.github.com/2901844
let s:ctags_opts = '
                \ --langdef=coffee
                \ --langmap=coffee:.coffee
                \ --regex-coffee=/(^|=[ \t])*class ([A-Za-z_][A-Za-z0-9_]+\.)*([A-Za-z_][A-Za-z0-9_]+)( extends ([A-Za-z][A-Za-z0-9_.]*)+)?$/\3/c,class/
                \ --regex-coffee=/^[ \t]*(module\.)?(exports\.)?@?(([A-Za-z][A-Za-z0-9_.]*)+):.*[-=]>.*$/\3/m,method/
                \ --regex-coffee=/^[ \t]*(module\.)?(exports\.)?(([A-Za-z][A-Za-z0-9_.]*)+)[ \t]*=.*[-=]>.*$/\3/f,function/
                \ --regex-coffee=/^[ \t]*(([A-Za-z][A-Za-z0-9_.]*)+)[ \t]*=[^->\n]*$/\1/v,variable/
                \ --regex-coffee=/^[ \t]*@(([A-Za-z][A-Za-z0-9_.]*)+)[ \t]*=[^->\n]*$/\1/f,field/
                \ --regex-coffee=/^[ \t]*@(([A-Za-z][A-Za-z0-9_.]*)+):[^->\n]*$/\1/f,static field/
                \ --regex-coffee=/^[ \t]*(([A-Za-z][A-Za-z0-9_.]*)+):[^->\n]*$/\1/f,field/
                \ --regex-coffee=/((constructor|initialize):[ \t]*\()@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?/\3/f,field/
                \ --regex-coffee=/((constructor|initialize):[ \t]*\()@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?(,[ \t]*@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?{0}/\8/f,field/
                \ --regex-coffee=/((constructor|initialize):[ \t]*\()@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?(,[ \t]*@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?{1}/\8/f,field/
                \ --regex-coffee=/((constructor|initialize):[ \t]*\()@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?(,[ \t]*@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?{2}/\8/f,field/
                \ --regex-coffee=/((constructor|initialize):[ \t]*\()@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?(,[ \t]*@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?{3}/\8/f,field/
                \ --regex-coffee=/((constructor|initialize):[ \t]*\()@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?(,[ \t]*@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?{4}/\8/f,field/
                \ --regex-coffee=/((constructor|initialize):[ \t]*\()@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?(,[ \t]*@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?{5}/\8/f,field/
                \ --regex-coffee=/((constructor|initialize):[ \t]*\()@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?(,[ \t]*@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?{6}/\8/f,field/
                \ --regex-coffee=/((constructor|initialize):[ \t]*\()@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?(,[ \t]*@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?{7}/\8/f,field/
                \ --regex-coffee=/((constructor|initialize):[ \t]*\()@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?(,[ \t]*@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?{8}/\8/f,field/
                \ --regex-coffee=/((constructor|initialize):[ \t]*\()@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?(,[ \t]*@(([A-Za-z][A-Za-z0-9_.]*)+)([ \t]*=[ \t]*[^,)]+)?{9}/\8/f,field/'

let $CTAGS = substitute(s:ctags_opts, '\v\([nst]\)', '\\\\\1', 'g')
if executable('coffeetags')
    let g:tagbar_type_coffee = {
                    \ 'ctagsbin' : 'coffeetags',
                    \ 'ctagsargs' : '--include-vars',
                    \ 'kinds' : [
                    \ 'f:functions',
                    \ 'o:object',
                    \ ],
                    \ 'sro' : ".",
                    \ 'kind2scope' : {
                    \ 'f' : 'object',
                    \ 'o' : 'object',
                    \ }
                    \ }
endif
let g:tagbar_type_go = {
                \ 'ctagstype' : 'go',
                \ 'kinds'     : [
                \ 'p:package',
                \ 'i:imports:1',
                \ 'c:constants',
                \ 'v:variables',
                \ 't:types',
                \ 'n:interfaces',
                \ 'w:fields',
                \ 'e:embedded',
                \ 'm:methods',
                \ 'r:constructor',
                \ 'f:functions'
                \ ],
                \ 'sro' : '.',
                \ 'kind2scope' : {
                \ 't' : 'ctype',
                \ 'n' : 'ntype'
                \ },
                \ 'scope2kind' : {
                \ 'ctype' : 't',
                \ 'ntype' : 'n'
                \ },
                \ 'ctagsbin'  : 'gotags',
                \ 'ctagsargs' : '-sort -silent'
                \ }
" \lでtaglistウインドウを開いたり閉じたり出来るショートカット
" SrcExpl
" ctag自動更新
" // The switch of the Source Explorer
if exists(":SrcExplToggle")
    nmap <Leader>se :SrcExplToggle<CR>
    let g:SrcExpl_UpdateTags = 1
    let g:SrcExpl_updateTagsCmd = "/usr/local/bin/ctags --sort=foldcase -R ."
endif
" soramugi/auto-ctags.vim
let g:auto_ctags = 1
let g:auto_ctags_directory_list = ['.git', '.svn']
let g:auto_ctags_tags_args = '--tag-relative --recurse --sort=yes'

" vim-indent-guides
if exists(":IndentGuideToggle")
    let g:indent_guides_auto_colors = 0
    let g:indent_guides_start_level = 1
    let g:indent_guides_guide_size = 1
endif

autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd  guibg=darkblue
autocmd VimEnter,Colorscheme * :hi IndentGuidesEven guibg=darkgrey
autocmd VimEnter,Colorscheme * IndentGuidesEnable

" tabular
let mapleader=','
if exists(":Tabularize")
    nmap <Leader>t= :Tabularize /=<CR>
    vmap <Leader>t= :Tabularize /=<CR>
    nmap <Leader>t: :Tabularize /:\zs<CR>
    vmap <Leader>t: :Tabularize /:\zs<CR>
endif

" NERDTree
" autocmd VimEnter,Colorscheme * :NERDTree
nmap <Leader>o :NERDTree<CR>
autocmd StdinReadPre * let s:std_in=1
autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | :cd ~/src | NERDTree | endif

" for Fugitive
nnoremap <Space>gd :<C-u>Gdiff<Enter>
nnoremap <Space>gs :<C-u>Gstatus<Enter>
nnoremap <Space>gl :<C-u>Glog<Enter>
nnoremap <Space>ga :<C-u>Gwrite<Enter>
nnoremap <Space>gc :<C-u>Gcommit<Enter>
nnoremap <Space>gC :<C-u>Git commit --amend<Enter>
nnoremap <Space>gb :<C-u>Gblame<Enter>

" ACK
"set grepprg=ack\ -a

" unite grep for ag
let g:unite_source_grep_command = 'ag'
let g:unite_source_grep_default_opts = '--nocolor --nogroup'
let g:unite_source_grep_recursive_opt = ''
let g:unite_source_grep_max_candidates = 200

" ag
set grepprg=ag

" grepで自動的にquickfix-windowを開く
autocmd QuickFixCmdPost *grep* cwindow
let &guifont='SourceCodePro-Light'

function! MyModified()
    if &filetype == "help"
        return ""
    elseif &modified
        return "+"
    elseif &modifiable
        return ""
    else
        return ""
    endif
endfunction

function! MyReadonly()
    if &filetype == "help"
        return ""
    elseif &readonly
        return "⭤"
    else
        return ""
    endif
endfunction

function! MyFugitive()
    return exists('*fugitive#head') ? fugitive#head() : ''
endfunction

function! MyFilename()
    return ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
                    \ ('' != expand('%t') ? expand('%t') : '[No Name]') .
                    \ ('' != MyModified() ? ' ' . MyModified() : '')
endfunction

" choosewin
" '-' で呼び出し
nmap  -  <Plug>(choosewin)

" オーバーレイを使う
let g:choosewin_overlay_enable = 1

" マルチバイトバッファでオーバーレイフォントを崩さないように
let g:choosewin_overlay_clear_multibyte = 1

" tmux の色に雰囲気を合わせる。
let g:choosewin_color_overlay = {
                \ 'gui': ['DodgerBlue3', 'DodgerBlue3' ],
                \ 'cterm': [ 25, 25 ]
                \ }
let g:choosewin_color_overlay_current = {
                \ 'gui': ['firebrick1', 'firebrick1' ],
                \ 'cterm': [ 124, 124 ]
                \ }

let g:choosewin_blink_on_land      = 0 " 頼むから着地時にカーソル点滅をさせないでくれ！
let g:choosewin_statusline_replace = 0 " どうかステータスラインリプレイスしないで下さい!
let g:choosewin_tabline_replace    = 0 " どうかタブラインもリプレイスしないでいただきたい！

" vim-easymotion
" Bi-directional find motion
" Jump to anywhere you want with minimal keystrokes, with just one key binding.
" `s{char}{label}`
nmap s <Plug>(easymotion-s)
" or
" `s{char}{char}{label}`
" Need one more keystroke, but on average, it may be more comfortable.
" nmap s <Plug>(easymotion-s2)

" JK motions: Line motions
map <Leader>j <Plug>(easymotion-j)
map <Leader>k <Plug>(easymotion-k)

let g:EasyMotion_smartcase = 1
let g:EasyMotion_use_smartsign_jp = 1 " JP layout
let g:EasyMotion_use_migemo = 1

" 'kana/vim-submode'
function! s:my_x()
    undojoin
    normal! "_x
endfunction
nnoremap <silent> <Plug>(my-x) :<C-u>call <SID>my_x()<CR>
call submode#enter_with('my_x', 'n', '', 'x', '"_x')
call submode#map('my_x', 'n', 'r', 'x', '<Plug>(my-x)')

"--------------------------------------------------
" Other Keybind Alias
"--------------------------------------------------
nnoremap j gj
nnoremap k gk
" 検索語を真ん中に
nmap n nzz
nmap N Nzz
nmap * *zz
nmap # #zz
nmap g* g*zz
nmap g# g#zz
"noremap ^? ^H
"noremap! ^? ^H
"noremap <BS> ^H
"noremap! <BS> ^H
inoremap <C-k> <Up>
inoremap <silent> <C-k> <Up>
inoremap <C-j> <Down>
inoremap <silent> <C-j> <Down>
" 検索時にエスケープなしに: http://qiita.com/m-yamashita/items/5755ca2717c8d5be57e4
" :help magic
nmap / /\v

" =の前後にスペース
"inoremap <expr> = smartchr#one_of(' = ', ' == ', ' === ', '=')
"noremap <expr> _  <SID>smart_char(' <- ', '_')

" C-JでEsc
nmap <C-j> <Esc>

" /と:M/を入れ替え(eregex.vim)
if exists(":M")
    "  nnoremap / :M/
    "  nnoremap ,/ /
endif
" コマンド履歴は打ち間違えるから移動
:nnoremap <Leader>: <Esc>q:
:nnoremap <Leader>/ <Esc>q/
:nnoremap <Leader>? <Esc>q?

:nnoremap q: <Nop>
:nnoremap q/ <Nop>
:nnoremap q? <Nop>

" 縦分割をする際、新しいウィンドウを右側に作る
set splitright
" 縦分割した後、カーソル下のタグへジャンプ
nnoremap ss :vsplit<ENTER><C-]>




" "," base mapping
let mapleader = ","
" キーバーインド一覧
nmap <C-t> :help index.txt<CR>
nmap <C-Y> :erb map
nmap <Leader>h :help index.txt<CR>
" Mapping Unite commands
nnoremap <Leader>/ :Unite grep:.<CR>
nnoremap <Leader>y :Unite -buffer-name=yank history/yank<CR>
nnoremap <Leader>l :Unite -buffer-name=buffers -quick-match buffer<CR>
" Mapping ropevim commands
nnoremap <Leader>g :call RopeGotoDefinition()<CR>
nnoremap <Leader>d :call RopeShowDoc()<CR>
nnoremap <Leader>f :call RopeFindOccurrences()<CR>
nnoremap <Leader>j :call RopeJumpToGlobal()<CR>
" Mapping tab commands
nnoremap <Leader>tc :tabc<CR>
nnoremap <Leader>tn :tabn<CR>
nnoremap <Leader>tp :tabp<CR>
nnoremap <Leader>te :tabe<space>
" Mapping Plugin commands
nnoremap <Leader>nt :NERDTreeToggle<CR>
nnoremap <Leader>tb :TagbarToggle<CR>
nnoremap <Leader>tl :TlistToggle<CR>
nnoremap <Leader>e :Errors<CR>
nnoremap <Leader>en :lnext<CR>
nnoremap <Leader>ep :lprev<CR>
" Adding Toggle Comment
nnoremap <Leader><Leader> :call NERDComment("n", "Toggle")<CR>
vnoremap <Leader><Leader> :call NERDComment("v", "Toggle")<CR>
" Add 'Sign' shortcut
nnoremap <Leader>si :exec "normal A".system("echo -n ' -- '$(git config --global --get user.name) $(date +\%D)")<CR>
" Map Paste / No Number for copy, paste, etc. in Vim without X.
nnoremap <Leader>p :set paste nonumber<CR>
nnoremap <Leader>np :set nopaste number<CR>
" X System Clipboard copy, cut, & paste shortcuts.
noremap <Leader>xp "+gP<CR>
noremap <Leader>xy "+y<CR>
noremap <Leader>xx "+x<CR>
" Compile (make) less to new CSS file
nnoremap <Leader>ml :w <BAR> !lessc % > %:t:r.css<CR><space>
" Spell Checking
nnoremap <Leader>sp :setlocal spell spelllang=en_us<CR>
nnoremap <Leader>nsp :setlocal spell spelllang=<CR>
" Write and Write & Quit shortcuts
nnoremap <Leader>s :w<CR>
nnoremap <Leader>q :wq<CR>
" Start vertical split command with space character.
nnoremap <Leader>v :vsp<space>
" Start horizontal split command with space character.
nnoremap <Leader>h :sp<space>
" Close window
nnoremap <Leader>cw :close<CR>
" Close buffer
nnoremap <Leader>bd :bd<CR>
" Clear highlighting
nnoremap <Leader>ch :noh<CR>
" Retab entire file
nnoremap <Leader>rt gg=G
" Insert a line above or below cursor without insert mode.
nnoremap <Leader>O O<Esc>
nnoremap <Leader>o o<Esc>
" Make arrow keys jump by 10 lines
nnoremap <S-Down> 10j
nnoremap <S-Up> 10k
imap <S-Down> <Esc>10ji
imap <S-Up> <Esc>10ki
vmap <S-Down> 10j
vmap <S-Up> 10k
" Send the selected hunk to IWS's hastebin
vmap <Leader>hb <esc>:'<,'>:w !HASTE_SERVER=http://hastebin.britecorepro.com haste<CR>
" Refresh syntax highlighting
nnoremap <Leader>rf :syntax off<CR>:syntax on<CR>
" Fix all the whitespace in a file. Re-tabs and removes trailing whitespace.
" Usage: ,ws
nnoremap <Leader>ws :TrimWS<CR>gg=G
" Insert a single character of your choosing and return to the right spot.
" Usage: ,[spacebar][character]
nnoremap <Leader><space> :exec "normal i".nr2char(getchar())."\e"<CR>
nnoremap <Leader>a :exec "normal a".nr2char(getchar())."\e"<CR>
" タグスタックジャンプ
nmap <C-*> :pop<CR>
" Write as super user
command! W w !sudo tee % > /dev/null
" Trim trailing whitespace
command TrimWS %s/\s*$//g | noh
" Visual Selection Search using * and #
function! s:VSetSearch()
    let temp = @@
    norm! gvy
    let @/ = '\V' . substitute(escape(@@, '\'), '\n', '\\n', 'g')
    let @@ = temp
endfunction
vnoremap * :<C-u>call <SID>VSetSearch()<CR>//<CR>
vnoremap # :<C-u>call <SID>VSetSearch()<CR>??<CR>
function LessToCss()
    let current_file = shellescape(expand('%:p'))
    let filename = shellescape(expand('%:r'))
    let command = "silent !lessc " . current_file . " " . filename . ".css"
    execute command
endfunction
autocmd BufWritePost,FileWritePost *.less call LessToCss()

"EasyAlign
" Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
vmap <Enter> <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)

" Syntastic
"let g:syntastic_<filetype>_checkers = ['']
let g:syntastic_sh_checkers = ['checkbashisms']
let g:syntastic_coffee_checkers = ['coffeelint']
let g:syntastic_javascript_checkers = ['jshint']
let g:syntastic_ecmascript_checkers = ['eslint']
let g:syntastic_typescript_checkers = ['tslint']
let g:syntastic_ruby_checkers = ['ruby-lint', 'rubocop']
let g:syntastic_html_checkers = ['']
let g:syntastic_scss_checkers = ['scss_lint']
let g:syntastic_check_on_open=1 " Run Syntastic when opening files
let g:syntastic_python_checkers=['python', 'pyflakes'] " Be more strict in python syntax
let g:syntastic_html_tidy_ignore_errors=[" proprietary attribute \"ng-"] " ignore AngularJS prefix attribute
let g:syntastic_go_checkers = ['golint', 'govet', 'errcheck']
let g:syntastic_mode_map = { 'mode': 'active', 'passive_filetypes': ['go'] }

let g:pymode_folding=0 " Turn off python-mode folding
let g:pymode_lint_write=0 " we have two lint plugins...
let g:pymode_utils_whitespaces=0 " don't molest whitespace
let g:ftplugin_sql_omni_key='<C-S>' " reset sql omni key
let NERDSpaceDelims=1 " Add space delimiters
let g:gitgutter_eager=0 " Only run gitgutter on read/write of files
" GitGutter Next/Prev Shortcuts
nmap gh <Plug>GitGutterNextHunk
nmap gH <Plug>GitGutterPrevHunk

" Javascript Debugger Function - inspired by pymode#breakpoint#Set
function JSDebugger(lnum)
    let line = getline(a:lnum)
    if strridx(line, "debugger;") != -1
        normal dd
    else
        let plnum = prevnonblank(a:lnum)
        call append(line('.')-1, repeat(' ', indent(plnum))."debugger;")
        normal k
    endif

    " Save file without any events
    if &modifiable && &modified | noautocmd write | endif
endfunction
au BufNewFile,BufReadPost *.js nnoremap <Leader>b :call JSDebugger(line('.'))<CR>

"jsbeautify
let g:Jsbeautify_jslint_whitespace = 0 "function(x) for 0 function (x) for 1
let g:Jsbeautify_jslint_expandtab = 1 "use spaces instead of tabs

" othree/javascript-libraries-syntax.vim
let g:used_javascript_libs = 'jquery,underscore,backbone,angularjs,chai'

autocmd FileType javascript noremap <buffer>  <c-f> :call JsBeautify()<cr>
" for html
autocmd FileType html noremap <buffer> <c-f> :call HtmlBeautify()<cr>
" for css or scss
autocmd FileType css noremap <buffer> <c-f> :call CSSBeautify()<cr>

set autoread
set updatetime=50

let s:system = exists('g:loaded_vimproc') ? 'vimproc#system_bg' : 'system'


" PATH
let $PATH="/usr/local/opt/coreutils/libexec/gnubin:/Users/kazuyukimori/.pyenv/bin:/Users/kazuyukimori/.rvm/bin:/Users/kazuyukimori/.go/bin:/Users/kazuyukimori/android-ndk-r8c:/Users/kazuyukimori/Library/Haskell/bin:/usr/local/share/npm/bin:/bin:/bin:/Users/kazuyukimori/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/go/bin:/Applications/MacVim.app/Contents/MacOS:/usr/local/mysql/bin:/Users/kazuyukimori/local/google-cloud-sdk/bin:/Users/kazuyukimori/local/gcutil-1.9.0"
let g:ackprg="/usr/local/bin/ack -H --nocolor --nogroup --column"
let g:agrg="/usr/local/bin/ag  --column"

augroup vim-auto-typescript
    autocmd!
    " 適当なタイミングで再読み込み
    autocmd CursorHold   *.ts :checktime
    autocmd CursorMoved  *.ts :checktime
    
    " 書き込み時に js に出力する
    autocmd BufWritePost *.ts :call {s:system}("tsc main.ts")
augroup END


if exists('b:did_ftplugin_typescript')
    finish
endif
let b:did_ftplugin_typescript = 1

setlocal tabstop=4
setlocal softtabstop=4
setlocal shiftwidth=4

if exists('*TSScompleteFunc') && &omnifunc ==# ''
  setlocal omnifunc=TSScompleteFunc
endif
